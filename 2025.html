<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="css/font.css">
        <link rel="stylesheet" href="css/css.css">

        <script src="https://cdn.jsdelivr.net/npm/animejs/dist/bundles/anime.umd.min.js"></script>

        <title>Adventsmarkt Projektion 2025</title>
    </head>
    <body>
        <img src="assets/img/outer-mask.svg" style="position: absolute; height: 100vh; width: 100vw; object-fit: contain; z-index: 10">
        <img src="assets/img/windows-mask.svg" style="position: absolute; height: 100vh; width: 100vw; object-fit: contain; z-index: 20">
        <script>
            const { animate, svg, stagger } = anime;
            (async () => {
                var svgElement = await fetch('assets/img/color.svg')
                    .then(response => response.text())
                    .then(text => new DOMParser().parseFromString(text, 'image/svg+xml').documentElement);
                svgElement.style.position = 'absolute';
                svgElement.style.height = '100vh';
                svgElement.style.width = '100vw';
                svgElement.style.objectFit = 'contain';
                svgElement.id = 'outline-svg';
                document.body.appendChild(svgElement);

                // calculate maximum distance from center for all paths
                const svgCenterX = svgElement.viewBox.baseVal.width / 2;
                const svgCenterY = svgElement.viewBox.baseVal.height / 2;
                const maxDistanceFromCenter = Math.hypot(0 - svgCenterX, 0 - svgCenterY);

                document.querySelectorAll("#outline-svg path:not([fill=none]").forEach((path) => {
                    var bbox = path.getBBox();
                    var centerOfRect_X = bbox.x + bbox.width / 2;
                    var centerOfRect_Y = bbox.y + bbox.height / 2;

                    // Store center coordinates as data attributes
                    path.dataset.centerX = centerOfRect_X;
                    path.dataset.centerY = centerOfRect_Y;

                    // Add index based on distance from SVG center
                    const distanceFromCenter = Math.hypot(centerOfRect_X - svgCenterX, centerOfRect_Y - svgCenterY);
                    path.dataset.distanceFromCenter = distanceFromCenter;
                    path.dataset.normalizedDistanceFromCenter = distanceFromCenter / maxDistanceFromCenter;
                });
                
                let distances = [...document.querySelectorAll("#outline-svg path:not([fill=none]")].map(p => [p, p.dataset.distanceFromCenter]).sort((a, b) => a[1] - b[1]);

                for (let index = 0; index < [...document.querySelectorAll("#outline-svg path:not([fill=none]")].length; index++) {
                    distances[index][0].dataset.distanceIndex = index;
                }

                animate("#outline-svg path:not([fill=none])", {
                    fill: "#00000000",
                    ease: 'inOutSine',
                    duration: 200,
                    delay: stagger(10 , { use: "data-distance-index" }),
                    loop: true,
                    alternate: true,
                });
            })();
        </script>
    </body>
</html>